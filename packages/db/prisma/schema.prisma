generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["extendedWhereUnique"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  SUPPORT
  SELLER
  BUYER
}

enum AddressType {
  SHIPPING
  BILLING
  OTHER
}

enum ListingStatus {
  DRAFT
  ACTIVE
  PAUSED
  SOLD
  ARCHIVED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  DECLINED
  COUNTERED
  WITHDRAWN
  EXPIRED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  FULFILLED
  CANCELLED
  REFUNDED
  DISPUTED
}

enum OrderEventType {
  CREATED
  PAYMENT_CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
  DISPUTE_OPENED
  DISPUTE_RESOLVED
  NOTE
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CHARGEBACK
}

enum PayoutStatus {
  PENDING
  RELEASED
  FAILED
}

enum ShipmentStatus {
  PREPARING
  SHIPPED
  DELIVERED
  RETURNED
  LOST
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  ESCALATED
  RESOLVED
  CLOSED
}

enum NotificationType {
  OFFER_RECEIVED
  OFFER_UPDATED
  ORDER_UPDATED
  DISPUTE_UPDATED
  SYSTEM
}

model User {
  id               String             @id @default(uuid())
  email            String             @unique
  passwordHash     String
  displayName      String
  bio              String?
  role             UserRole           @default(BUYER)
  phoneNumber      String?
  avatarUrl        String?
  emailVerified    DateTime?
  dateOfBirth      DateTime?
  ageVerifiedAt    DateTime?
  policyAcceptances PolicyAcceptance[]
  marketingOptIn   Boolean            @default(false)
  twoFactorEnabled Boolean            @default(false)
  twoFactorSecret  String?
  stripeCustomerId String?            @unique
  stripeConnectId  String?            @unique
  lastLoginAt      DateTime?
  listings         Listing[]          @relation("ListingSeller")
  offers           Offer[]            @relation("OfferBuyer")
  ordersBought     Order[]            @relation("OrderBuyer")
  ordersSold       Order[]            @relation("OrderSeller")
  disputesRaised   Dispute[]          @relation("DisputeRaisedBy")
  disputesAssigned Dispute[]          @relation("DisputeAssignedTo")
  disputeMessages  DisputeMessage[]
  addresses        Address[]
  notifications    Notification[]
  accounts         Account[]
  sessions         Session[]
  totpDevices      TotpDevice[]
  carts            Cart[]
  payouts          Payout[]          @relation("SellerPayouts")
  auditLogs        AuditLog[]        @relation("UserAuditLogs")
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
}

model Account {
  id                 Int      @id @default(autoincrement())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model TotpDevice {
  id          String   @id @default(uuid())
  userId      String
  secret      String
  label       String?
  verifiedAt  DateTime?
  lastUsedAt  DateTime?
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PolicyAcceptance {
  id        String   @id @default(uuid())
  userId    String
  policy    String
  version   String
  acceptedAt DateTime @default(now())
  ipAddress String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, policy, version], map: "idx_policy_acceptance_user_policy_version")
}

model Address {
  id          String      @id @default(uuid())
  userId      String
  label       String?
  type        AddressType @default(SHIPPING)
  line1       String
  line2       String?
  city        String
  state       String?
  postalCode  String
  country     String
  isDefault   Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  shippingFor Order[]     @relation("OrderShippingAddress")
  billingFor  Order[]     @relation("OrderBillingAddress")
}

model Listing {
  id           String          @id @default(uuid())
  sellerId     String
  title        String
  slug         String          @unique
  description  String
  price        Decimal         @db.Decimal(10, 2)
  currency     String          @default("USD")
  quantity     Int             @default(1)
  status       ListingStatus   @default(DRAFT)
  category     String?
  tags         String[]        @default([])
  publishedAt  DateTime?
  archivedAt   DateTime?
  seller       User            @relation("ListingSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  offers       Offer[]
  orders       Order[]
  cartItems    CartItem[]
  orderItems   OrderItem[]
  images       ListingImage[]
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@index([status], map: "idx_listing_status")
  @@index([sellerId, status], map: "idx_listing_seller_status")
}

model ListingImage {
  id        String   @id @default(uuid())
  listingId String
  url       String
  altText   String?
  position  Int      @default(0)
  isPrimary Boolean  @default(false)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
}

model Offer {
  id          String      @id @default(uuid())
  listingId   String
  buyerId     String
  amount      Decimal     @db.Decimal(10, 2)
  status      OfferStatus @default(PENDING)
  message     String?
  expiresAt   DateTime?
  respondedAt DateTime?
  counterAmount Decimal?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  listing     Listing     @relation(fields: [listingId], references: [id], onDelete: Cascade)
  buyer       User        @relation("OfferBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  order       Order?       @relation("OfferOrder")
  cartItem    CartItem?    @relation("OfferCartItem")
  orderItems  OrderItem[]  @relation("OfferOrderItems")
}

model Order {
  id                 String              @id @default(uuid())
  listingId          String
  buyerId            String
  sellerId           String
  offerId            String?             @unique
  shippingAddressId  String?
  billingAddressId   String?
  status             OrderStatus         @default(PENDING)
  totalAmount        Decimal             @db.Decimal(12, 2)
  currency           String              @default("USD")
  quantity           Int                 @default(1)
  submittedAt        DateTime?           @default(now())
  fulfilledAt        DateTime?
  cancelledAt        DateTime?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  listing            Listing             @relation(fields: [listingId], references: [id], onDelete: Cascade)
  buyer              User                @relation("OrderBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  seller             User                @relation("OrderSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  offer              Offer?              @relation("OfferOrder", fields: [offerId], references: [id])
  payment            Payment?
  shipment           Shipment?
  timelineEvents     OrderTimelineEvent[]
  disputes           Dispute[]
  items              OrderItem[]
  paymentIntents     PaymentIntent[]
  payout             Payout?
  shippingAddress    Address?            @relation("OrderShippingAddress", fields: [shippingAddressId], references: [id])
  billingAddress     Address?            @relation("OrderBillingAddress", fields: [billingAddressId], references: [id])
}

model OrderTimelineEvent {
  id        String          @id @default(uuid())
  orderId   String
  type      OrderEventType
  detail    String
  metadata  Json?
  createdAt DateTime        @default(now())
  order     Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Payment {
  id              String        @id @default(uuid())
  orderId         String        @unique
  status          PaymentStatus @default(PENDING)
  amount          Decimal       @db.Decimal(12, 2)
  provider        String?
  transactionRef  String?
  paidAt          DateTime?
  currency        String?
  applicationFeeAmount Decimal? @db.Decimal(12, 2)
  taxAmount       Decimal?      @db.Decimal(12, 2)
  escrowAmount    Decimal?      @db.Decimal(12, 2)
  stripePaymentIntentId String? @unique
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  order           Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model PaymentIntent {
  id         String        @id @default(uuid())
  orderId    String
  stripeId   String        @unique
  clientSecret String?
  status     String
  amount     Decimal       @db.Decimal(12, 2)
  currency   String        @default("USD")
  metadata   Json?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  order      Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Cart {
  id        String     @id @default(uuid())
  buyerId   String
  active    Boolean    @default(true)
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  buyer     User       @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  @@index([buyerId, active], map: "idx_cart_buyer_active")
}

model CartItem {
  id         String   @id @default(uuid())
  cartId     String
  listingId  String
  offerId    String?  @unique
  quantity   Int      @default(1)
  unitPrice  Decimal  @db.Decimal(10, 2)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  cart       Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  offer      Offer?   @relation("OfferCartItem", fields: [offerId], references: [id])

  @@index([cartId], map: "idx_cart_item_cart")
}

model OrderItem {
  id         String   @id @default(uuid())
  orderId    String
  listingId  String
  offerId    String?
  quantity   Int      @default(1)
  unitPrice  Decimal  @db.Decimal(10, 2)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  order      Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  offer      Offer?   @relation("OfferOrderItems", fields: [offerId], references: [id])
}

model Payout {
  id          String       @id @default(uuid())
  orderId     String       @unique
  sellerId    String
  amount      Decimal      @db.Decimal(12, 2)
  currency    String       @default("USD")
  status      PayoutStatus @default(PENDING)
  transferId  String?      @unique
  releasedAt  DateTime?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  order       Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  seller      User         @relation("SellerPayouts", fields: [sellerId], references: [id], onDelete: Cascade)
}

model Shipment {
  id             String         @id @default(uuid())
  orderId        String         @unique
  status         ShipmentStatus @default(PREPARING)
  carrier        String?
  trackingNumber String?
  shippedAt      DateTime?
  deliveredAt    DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  order          Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Dispute {
  id             String         @id @default(uuid())
  orderId        String         @unique
  raisedById     String
  assignedToId   String?
  status         DisputeStatus  @default(OPEN)
  reason         String
  resolution     String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  resolvedAt     DateTime?
  order          Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  raisedBy       User           @relation("DisputeRaisedBy", fields: [raisedById], references: [id], onDelete: Cascade)
  assignedTo     User?          @relation("DisputeAssignedTo", fields: [assignedToId], references: [id])
  messages       DisputeMessage[]
}

model DisputeMessage {
  id         String   @id @default(uuid())
  disputeId  String
  authorId   String
  body       String
  isInternal Boolean  @default(false)
  createdAt  DateTime @default(now())
  dispute    Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  author     User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String            @id @default(uuid())
  userId    String
  type      NotificationType
  payload   Json
  readAt    DateTime?
  createdAt DateTime          @default(now())
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id        String   @id @default(uuid())
  actorId   String?
  entity    String
  entityId  String
  action    String
  metadata  Json?
  createdAt DateTime @default(now())
  actor     User?    @relation("UserAuditLogs", fields: [actorId], references: [id])
}
